## 複雜性

複雜性 論規模，軟體實體複雜的程度恐怕任何其他人為的創作都比跟以上，因為沒有任何兩個部分是一樣的（至少就單行程式敘述這個層級以上而言），假如一樣，我們會把一樣的部分弄成一份，雙成一個公開或私下使用的副程式。然而電腦硬體、房屋建築或汽車製造卻能夠大量重複使用零件，在這方面，軟體系統是極大的不同。
數位電腦本身就比大部分人們建造的東西要更複雜，它們有一大堆狀態，這使得理解、描述和測試它們都非常困難，而軟體系統中的狀態又比電腦更多出幾個數量級。
同樣地，將一個軟體實體擴大規模（scaling up）的時候，不僅僅將重複使用為數更多的相同元素，不同元素的數量也勢必增加，在大部分的情形下，這些元素彼此交互作用的程度是呈非線性成長，而整個複雜度增加的情況也遠遠超過線性預估的結果。
軟體的複雜是屬於本質上的特性，而非附屬的特性，所以，對於一個軟體實體所做的描述，若將其複雜性抽離，結果往往也連帶抽離了它的本質。數學和物理學之所以能在過去三個世紀突飛猛進，就是藉由為複雜現象建立出簡單的模型（model），然後從模型中推導出現象的特性，並透過實驗來驗證這些特性。這種方式之所以行得通，是因為在模型中所排除掉的複雜性並非現象的本質，如果這些複雜性是屬於本質上的特性，那就行不通了。
許多軟體產品開發的老問題都是源自於本質上的複雜性，以及複雜性隨著軟體規模呈非線性成長的特性。因為複雜性，使開發團隊的成員溝通困難，進而導致了產品的瑕疵、成本的超支、時程的落後；因為複雜性，使程式裏可能的狀態更加難以一一列舉，也更加難明瞭，進而使產品變得很不可靠；因為功能上的複雜性，使得這些功能難以運用，並造成程式使用上的不方便；因為結構上的複雜性，使程式在擴充新功能的時候，難保不會產生副作用；因為結構上的複雜性，使一些不易察覺的狀態成了安全上的漏洞。
不僅僅是技術上的問題，複雜性也會導致管理上的問題。複雜性造成難以看出系統的概觀，於是阻礙了概念整體性（conceptual integrity）；複雜性造成難以發現並控制所有該做而未做的事；複雜性造成了學習與理解上的巨大負擔，使人員的異動形同是個災難。
